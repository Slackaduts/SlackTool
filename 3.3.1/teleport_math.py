import asyncio
from wizwalker import XYZ, Client, Keycode
from wizwalker.file_readers.wad import Wad
import math
import struct
from io import BytesIO
from typing import Tuple, Union
from utils import is_free

type_format_dict = {
"char": "<c",
"signed char": "<b",
"unsigned char": "<B",
"bool": "?",
"short": "<h",
"unsigned short": "<H",
"int": "<i",
"unsigned int": "<I",
"long": "<l",
"unsigned long": "<L",
"long long": "<q",
"unsigned long long": "<Q",
"float": "<f",
"double": "<d",
}




class TypedBytes(BytesIO):
	def split(self, index: int) -> Tuple["TypedBytes", "TypedBytes"]:
		self.seek(0)
		buffer = self.read(index)
		return type(self)(buffer), type(self)(self.read())
	def read_typed(self, type_name: str):
		type_format = type_format_dict[type_name]
		size = struct.calcsize(type_format)
		data = self.read(size)
		return struct.unpack(type_format, data)[0]


# implemented from https://github.com/PeechezNCreem/navwiz/
# this licence covers the below function
# Boost Software License - Version 1.0 - August 17th, 2003
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

def parse_nav_data(file_data: Union[bytes, TypedBytes]):
	# ty starrfox for remaking this
	if isinstance(file_data, bytes):
		file_data = TypedBytes(file_data)
	vertex_count = file_data.read_typed("short")
	vertex_max = file_data.read_typed("short")
	# unknown bytes
	file_data.read_typed("short")
	vertices = []
	idx = 0
	while idx <= vertex_max - 1:
		x = file_data.read_typed("float")
		y = file_data.read_typed("float")
		z = file_data.read_typed("float")
		vertices.append(XYZ(x, y, z))
		vertex_index = file_data.read_typed("short")
		if vertex_index != idx:
			vertices.pop()
			vertex_max -= 1
		else:
			idx += 1
	edge_count = file_data.read_typed("int")
	edges = []
	for idx in range(edge_count):
		start = file_data.read_typed("short")
		stop = file_data.read_typed("short")
		edges.append((start, stop))
	return vertices, edges


def calc_PointOn3DLine(xyz_1 : XYZ, xyz_2 : XYZ, additional_distance):
	# extends a point on the line created by 2 XYZs by additional_distance. xyz_1 is the origin.
	distance = math.sqrt((pow(xyz_1.x - xyz_2.x, 2.0)) + (pow(xyz_1.y - xyz_2.y, 2.0)) + (pow(xyz_1.z - xyz_2.z, 2.0)))
	n = ((distance - additional_distance) / distance)
	return XYZ(x=((xyz_2.x - xyz_1.x) * n) + xyz_1.x, y=((xyz_2.y - xyz_1.y) * n) + xyz_1.y, z=((xyz_2.z - xyz_1.z) * n) + xyz_1.z)


def calc_multiplerPointOn3DLine(xyz_1 : XYZ, xyz_2 : XYZ, multiplier : float):
	# extends a point on the line created by 2 XYZs by a multiplier. xyz_1 is the origin.
	return XYZ(x=((xyz_2.x - xyz_1.x) * multiplier) + xyz_1.x, y=((xyz_2.y - xyz_1.y) * multiplier) + xyz_1.y, z=((xyz_2.z - xyz_1.z) * multiplier) + xyz_1.z)


def calc_MidPoint(xyz_1 : XYZ, xyz_2 : XYZ, distance_multiplier : float = 0.5):
	# calculates the midpoint of 2 XYZs. 
	distance = math.sqrt((pow(xyz_1.x - xyz_2.x, 2.0)) + (pow(xyz_1.y - xyz_2.y, 2.0)) + (pow(xyz_1.z - xyz_2.z, 2.0)))
	n = distance_multiplier
	return XYZ(x=((xyz_2.x - xyz_1.x) * n) + xyz_1.x, y=((xyz_2.y - xyz_1.y) * n) + xyz_1.y, z=((xyz_2.z - xyz_1.z) * n) + xyz_1.z)


def calc_AveragePoint(xyz_list : list[XYZ]):
	# calculates the "midpoint" of a list of XYZs. 
	x_list = [x.x for x in xyz_list]
	y_list = [y.y for y in xyz_list]
	z_list = [z.z for z in xyz_list]
	return XYZ(x=(sum(x_list) / len(x_list)), y=(sum(y_list) / len(y_list)), z=(sum(z_list) / len(z_list)))


def rotate_point(origin_xyz : XYZ, point_xyz : XYZ, theta):
	# rotates point_xyz about origin_xyz, by theta degrees counterclockwise. This doesn't take the Z into account, so don't use this for anything that needs the Z to rotate.
	radians = math.radians(theta)
	cos = math.cos(radians)
	sin = math.sin(radians)
	y_diff = point_xyz.y - origin_xyz.y
	x_diff = point_xyz.x - origin_xyz.x
	x = cos * x_diff - sin * y_diff + origin_xyz.x
	y = sin * x_diff + cos * y_diff + origin_xyz.y
	return XYZ(x=x, y=y, z=point_xyz.z)


def are_xyzs_within_threshold(xyz_1 : XYZ, xyz_2 : XYZ, threshold : int = 200):
	# checks if 2 xyz's are within a rough distance threshold of each other. Not actual distance checking, but precision isn't needed for this, this exists to eliminate tiny variations in XYZ when being sent back from a failed port.
	threshold_check = [abs(abs(xyz_1.x) - abs(xyz_2.x)) < threshold, abs(abs(xyz_1.y) - abs(xyz_2.y)) < threshold, abs(abs(xyz_1.z) - abs(xyz_2.z)) < threshold]
	return all(threshold_check)


def calc_Distance(xyz_1 : XYZ, xyz_2 : XYZ):
	# calculates the distance between 2 XYZs
	return math.sqrt((pow(xyz_1.x - xyz_2.x, 2.0)) + (pow(xyz_1.y - xyz_2.y, 2.0)) + (pow(xyz_1.z - xyz_2.z, 2.0)))


def calc_squareDistance(xyz_1 : XYZ, xyz_2 : XYZ):
	# calculates the distance between 2 XYZs, but doesn't square root the answer to be much more efficient. Useful for comparing distances, not much else.
	return (pow(xyz_1.x - xyz_2.x, 2.0)) + (pow(xyz_1.y - xyz_2.y, 2.0)) + (pow(xyz_1.z - xyz_2.z, 2.0))


async def calc_up_XYZ(client: Client, xyz : XYZ = None, speed_constant : int = 580, speed_adjusted : bool = True):
	# handles optional xyz param, will default to using the position of the client
	if not xyz:
		client_xyz = await client.body.position()
	else:
		client_xyz = xyz

	# handles speed adjustment param
	if speed_adjusted:	
		additional_speed = await client.client_object.speed_multiplier()
	else:
		additional_speed = 0

	# adjusts speed constant based on speed multiplier, and adds it to the Z value
	new_z = client_xyz.z + (speed_constant * ((additional_speed / 100) + 1))

	return XYZ(x=client_xyz.x, y=client_xyz.y, z=new_z)


async def calc_FrontalVector(client: Client, xyz : XYZ = None, yaw : float = None, speed_constant : int = 580, speed_adjusted : bool = True, length_adjusted : bool = True):
	# handle if it is adjusted via speed multiplier or just uses the set constant
	if speed_adjusted:
		current_speed = await client.client_object.speed_multiplier()
	else:
		current_speed = 0

	# handles optional xyz param, will default to using the position of the client
	if not xyz:
		xyz = await client.body.position()

	# handles optional yaw paraam, will default to using the yaw of the client
	if not yaw:
		yaw = await client.body.yaw()
	else:
		yaw = yaw

	# adjust the speed constant based on the speed multiplier
	additional_distance = speed_constant * ((current_speed / 100) + 1)

	# calculate point "in front" of XYZ/client using yaw 
	frontal_x = (xyz.x - (additional_distance * math.sin(yaw)))
	frontal_y = (xyz.y - (additional_distance * math.cos(yaw)))
	frontal_xyz = XYZ(x=frontal_x, y=frontal_y, z=xyz.z)

	# make a length adjustment since diagonal movements 
	if length_adjusted:
		distance = calc_Distance(xyz, frontal_xyz)
		final_xyz = calc_PointOn3DLine(xyz_1=xyz, xyz_2=frontal_xyz, additional_distance=(additional_distance - distance))
	else:
		final_xyz = frontal_xyz

	return final_xyz


async def teleport_move_adjust(client: Client, xyz : XYZ, delay : float = 0.8):
	# teleports the client to a given XYZ, and jitters afterward to actually update the position
	if await is_free(client):
		try:
			await client.teleport(xyz, wait_on_inuse= True, purge_on_after_unuser_fixer= True)
		except ValueError:
			pass
	await client.send_key(Keycode.A, 0.05)
	await client.send_key(Keycode.D, 0.05)
	await asyncio.sleep(delay)


async def is_teleport_valid(client: Client, destination_xyz : XYZ, origin_xyz : XYZ):
	# checks if a client actually teleported to its destination.
	original_zone_name = await client.zone_name()
	await teleport_move_adjust(destination_xyz)

	# we know the teleport didn't succeed if we are very close to where we were, and the zone name hasn't changed
	if are_xyzs_within_threshold(await client.body.position(), origin_xyz, 50) and await client.zone_name() == original_zone_name:
		return False
	else:
		return True


async def auto_adjusting_teleport(client: Client):
	# DEPRECATED: Uses brute forcing XYZs in an alternating spiral pattern to find usable coords to port to. VERY slow.
	original_zone_name = await client.zone_name()
	original_position = await client.body.position()
	quest_position = await client.quest_position.position()
	adjusted_position = quest_position
	mod_amount = 50
	current_angle = 0
	await teleport_move_adjust(client, quest_position)
	while are_xyzs_within_threshold((await client.body.position()), original_position, 50) and await client.zone_name() == original_zone_name:
		adjusted_position = calc_PointOn3DLine(original_position, quest_position, mod_amount)
		rotated_position = rotate_point(quest_position, adjusted_position, current_angle)
		await teleport_move_adjust(client, rotated_position)
		mod_amount += 100
		current_angle += 92


async def load_wad(path: str):
	if path is not None:
		return Wad.from_game_data(path.replace("/", "-"))


async def split_walk(client: Client, xyz: XYZ = None, segments: int = 5, original_zone: str = None):
	if not original_zone:
		original_zone = await client.zone_name()

	if not xyz:
		xyz = await client.quest_position.position()

	# walks to desired XYZ, only if the zone hasn't changed and if the param is enabled.

	current_pos = await client.body.position()
	points_on_line = [calc_multiplerPointOn3DLine(xyz_1=current_pos, xyz_2=xyz, multiplier=((i + 1) / segments)) for i in range(segments - 2)]
	points_on_line.append(xyz)
	for point_xyz in points_on_line:
		# print('for loop for split walking')
		if not await is_free(client) or await client.zone_name() != original_zone:
			break

		try:
			await client.goto(point_xyz.x, point_xyz.y)
		except:
			pass
		await asyncio.sleep(0.1)


async def navmap_tp(client: Client, xyz: XYZ = None, minimum_distance_increment: int = 250, walk_after=True):
	if await is_free(client):
		original_zone_name = await client.zone_name()
		original_position = await client.body.position()
		if xyz:
			quest_pos = xyz
		else:
			quest_pos = await client.quest_position.position()
		minimum_vertex_distance = minimum_distance_increment
		await teleport_move_adjust(client, quest_pos)
		while not await is_free(client):
			await asyncio.sleep(0.1)
		current_zone = await client.zone_name()
		wad = await load_wad(current_zone)
		nav_data = await wad.get_file("zone.nav")
		vertices = []
		try:
			vertices, _ = parse_nav_data(nav_data)
		except:
			if walk_after:
				await split_walk(client, quest_pos, original_zone=original_zone_name)
		squared_distances = [calc_squareDistance(quest_pos, n) for n in vertices]
		sorted_distances = sorted(squared_distances)
		while True:
		# while are_xyzs_within_threshold(xyz_1=(await client.body.position()), xyz_2=original_position, threshold=100) and await client.zone_name() == original_zone_name and not await client.is_loading():
			current_pos = await client.body.position()
			if await client.zone_name() == original_zone_name and await is_free(client):
				if are_xyzs_within_threshold(xyz_1=current_pos, xyz_2=original_position, threshold=100):
					pass
				else:
					break
			else:
				break
			# set minimum distance between 2 chosen vertices
			minimum_vertex_distance += minimum_distance_increment
			for s in sorted_distances:
				current_index = sorted_distances.index(s)
				if current_index + 1 < len(sorted_distances):
					# this is REALLY inefficient but I'll fix it later maybe
					# selection of the 2 closest vertices that satisfy the criteria
					vertex = vertices[int(squared_distances.index(sorted_distances[current_index]))]
					next_vertex = vertices[int(squared_distances.index(sorted_distances[current_index + 1]))]
					between_vertices = calc_Distance(vertex, next_vertex)
					quest_to_vertex = calc_Distance(quest_pos, next_vertex)
					if between_vertices >= quest_to_vertex or between_vertices < minimum_vertex_distance:
						pass
					elif between_vertices < quest_to_vertex and between_vertices >= minimum_vertex_distance:
						adjusted_pos = calc_AveragePoint([vertex, next_vertex, quest_pos, quest_pos])
						final_adjusted_pos = XYZ(x=adjusted_pos.x, y=adjusted_pos.y, z=max([quest_pos.z, adjusted_pos.z]))
						if await client.zone_name() == original_zone_name and await is_free(client):
							await teleport_move_adjust(client, final_adjusted_pos)
						elif not await is_free(client):
							break
						break
					else:
						pass
				else:
					break
		if walk_after:
			await split_walk(client, quest_pos, original_zone=original_zone_name)
		await asyncio.sleep(0.3)
		current_pos = await client.body.position()
		current_quest_pos = await client.quest_position.position()
		current_zone = await client.zone_name()
		if are_xyzs_within_threshold(xyz_1 = current_pos, xyz_2 = quest_pos, threshold = 25) == False and are_xyzs_within_threshold(xyz_1 = current_quest_pos, xyz_2 = quest_pos, threshold = 5) and current_zone == original_zone_name:
			await auto_adjusting_teleport(client)


# async def async_threshold_check(xyz_1: XYZ, xyz_2: XYZ, threshold: int = 25):
# 	# Async replacement for are_xys_within_threshold()
# 	await asyncio.sleep(0)
# 	print('async threshold check 1')
# 	return not (calc_Distance(xyz_1, xyz_2) > threshold)


# async def checked_tp(client: Client, original_zone: str, xyz: XYZ):
# 	# Teleport that checks if it succeeded. Returns True if teleport succeeded.
# 	print('checked tp 1')
# 	current_pos = await client.body.position()
# 	print('checked tp 2')
# 	await teleport_move_adjust(client, xyz)
# 	print('checked tp 3')
# 	after_pos = await client.body.position()
# 	print('checked tp 4')
# 	current_zone = await client.zone_name()
# 	await asyncio.sleep(0)
# 	tp_status = are_xyzs_within_threshold(current_pos, after_pos, 25) and current_zone == original_zone
# 	tp_status ^= True
# 	print('checked tp 5')
# 	return tp_status


# async def sort_points(origin_xyz: XYZ, points: list[XYZ], descending: bool = False):
# 	# Sorts points based off (asending by default) distance to the origin_XYZ.
# 	sorted_distances = []
# 	sorted_points = []
# 	print('sort points 1')
# 	for xyz in points:
# 		xyz_distance = calc_squareDistance(origin_xyz, xyz)
# 		print('sort points 2')
# 		if sorted_distances:
# 			print('sort points 3')
# 			for i, distance in enumerate(sorted_distances.copy()):
# 				print('sort points 4')
# 				await asyncio.sleep(0)
# 				if xyz_distance > distance:
# 					print('sort points 5')
# 					# If distance is greater than the current iteration, add the current XYZ and distance at the current index
# 					sorted_distances.insert(i, xyz_distance)
# 					print('sort points 6')
# 					sorted_points.insert(i, xyz)
# 					print('sort points 7')
# 					break
# 			else:
# 				sorted_distances.insert(0, xyz_distance)
# 				print('sort points 8')
# 				sorted_points.insert(0, xyz)
# 				print('sort points 9')
# 		else:
# 			# First point, therefore it's just marked
# 			sorted_distances.append(xyz_distance)
# 			print('sort points 10')
# 			sorted_points.append(xyz)
# 			print('sort points 11')

# 	if not descending:
# 		print('sort points 12')
# 		sorted_points.reverse()
# 		print('sort points 13')

# 	await asyncio.sleep(0)
# 	print('sort points 14')
# 	print(sorted_distances)
# 	return sorted_points


# async def filter_points(origin_xyz: XYZ, points: list[XYZ], min_point_distance: int = 25, maximum_point_angle: int = 270):
# 	# Filter a list of sorted points based on criteria like distance between 2 points, etc
# 	if points:
# 		print('filter points 1')
# 		previous_xyz = points[0]
# 		print('filter points 2')
# 		for xyz in points.copy():
# 			print('filter points 3')
# 			await asyncio.sleep(0)
# 			# xyz_to_point_distance = calc_Distance(xyz, origin_xyz)
# 			origin_to_xyz_dist = calc_Distance(origin_xyz, xyz)
# 			print('filter points 3')
# 			prev_to_curr_xyz_dist = calc_Distance(previous_xyz, xyz)
# 			print('filter points 4')
# 			if prev_to_curr_xyz_dist < min_point_distance or origin_to_xyz_dist > prev_to_curr_xyz_dist:
# 				print('filter points 5')
# 				points.remove(xyz)
# 				print('filter points 6')
# 				continue

# 	print('filter points 7')
# 	return points


# async def tp_from_vertices(client: Client, vertices: list[XYZ], destination_xyz: XYZ, walk_after: bool = True, minimum_distance_increment: int = 250, original_zone: str = None):
# 	# Uses provided list of vertices (navmap provided usually) to assist in teleporting to walkable coordinates.
# 	if await is_free(client):
# 		print('tp from vertices 1')
# 		if not original_zone:
# 			print('tp from vertices 2')
# 			original_zone = await client.zone_name()

# 		print('tp from vertices 3')
# 		sorted_vertices = await sort_points(destination_xyz, vertices)
# 		print('tp from vertices 4')
# 		filtered_vertices = await filter_points(destination_xyz, sorted_vertices)
# 		print('tp from vertices 5')

# 		exit_tp_loop = False
# 		minimum_vertex_distance = minimum_distance_increment
# 		while True:
# 			print('tp from vertices 6')
# 			for i, xyz in enumerate(filtered_vertices):
# 				print('tp from vertices 7')
# 				points_to_average = [xyz]
# 				print('tp from vertices 8')
# 				# Get next point as well, if it exists
# 				if (i + 1) < len(filtered_vertices):
# 					print('tp from vertices 9')
# 					points_to_average.append(filtered_vertices[i + 1])
# 					print('tp from vertices 10')

# 				# Also use the destination 
# 				points_to_average.append(destination_xyz)
# 				print('tp from vertices 11')
# 				points_to_average.append(destination_xyz)
# 				print('tp from vertices 12')

# 				adjusted_point = calc_AveragePoint(points_to_average)
# 				print('tp from vertices 13')
# 				final_adjusted_point = XYZ(x=adjusted_point.x, y=adjusted_point.y, z=max([destination_xyz.z, adjusted_point.z]))
# 				print('tp from vertices 14')

# 				if await client.zone_name() == original_zone and await is_free(client):
# 					print('tp from vertices 15')
# 					tp_status = await checked_tp(client, original_zone, final_adjusted_point)
# 					if not tp_status:
# 						print('tp from vertices 16')
# 						exit_tp_loop = True
# 						print('tp from vertices 17')
# 						if walk_after:
# 							print('tp from vertices 18')
# 							walk_to_xyz = True
# 							print('tp from vertices 19')
# 						break
# 					else:
# 						minimum_vertex_distance += minimum_distance_increment
# 						print('tp from vertices 20')
# 				else:
# 					exit_tp_loop = True
# 					print('tp from vertices 21')
# 					break
# 			else:
# 				break

# 			if exit_tp_loop:
# 				print('tp from vertices 22')
# 				break

# 		current_pos = await client.body.position()

# 		if await is_free(client) and walk_to_xyz:
# 			print('tp from vertices 23')
# 			if not are_xyzs_within_threshold(xyz, current_pos):
# 				await split_walk(client, xyz)
# 			print('tp from vertices 24')


# async def navmap_tp(client: Client, destination_xyz: XYZ, walk_after: bool = True, minimum_distance_increment: int = 250, original_zone: str = None):
# 	# Uses the navmap to assist in teleporting to walkable areas.
# 	if await is_free(client):
# 		print('navmap tp 1')
# 		if not original_zone:
# 			print('navmap tp 2')
# 			original_zone = await client.zone_name()

# 		if destination_xyz:
# 			print('navmap tp 3')
# 			quest_pos = destination_xyz
# 		else:
# 			quest_pos = await client.quest_position.position()
		
# 		print('navmap tp 4')
# 		tp_status = await checked_tp(client, original_zone, destination_xyz)
# 		if not tp_status:
# 			print('navmap tp 5')
# 			wad = await load_wad(original_zone)
# 			print('navmap tp 6')
# 			nav_data = await wad.get_file("zone.nav")
# 			print('navmap tp 7')
# 			vertices = []
# 			try:
# 				print('navmap tp 8')
# 				vertices, _ = parse_nav_data(nav_data)
# 				print('navmap tp 9')
# 			except:
# 				# If navmap does not exist for this zone, use brute force TP
# 				print('navmap tp 10')
# 				await auto_adjusting_teleport(client)
# 				print('navmap tp 11')
# 				if walk_after and await is_free(client):
# 					print('navmap tp 12')
# 					await split_walk(client, quest_pos, original_zone = original_zone)
# 					print('navmap tp 13')
# 			else:
# 				print('navmap tp 14')
# 				await tp_from_vertices(client, vertices, destination_xyz, walk_after, minimum_distance_increment, original_zone)
# 				print('navmap tp 15')


async def collision_tp(client, xyz):
	pass


def calc_angle(p1 : XYZ, p2 : XYZ, p3 : XYZ = None):
	if not p3:
		p3 = XYZ(x=p1.x, y=p2.y, z=p1.z)
	return math.degrees(math.atan2(p3.y - p1.y, p3.x - p1.x) - math.atan2(p2.y - p1.y, p2.x - p1.x))